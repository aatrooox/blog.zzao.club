---
title: "OpenClaw 支持 ACP Agent 了！Opencode / Codex / clade / gemini 已支持"
date: "YYYY-MM-DD"
author: "Aatrox"
tags:
  - OpenClaw
  - ACP
  - Agents
  - Opencode
  - Codex
  - Claude
  - Gemini
  - 配置
---

这次 OpenClaw 的更新，核心就两件事：

- **支持 ACP Agents**：把“会干活的 Agent”用更标准的方式接进来
- **配置更清晰**：你终于可以像配服务一样配 Agent 了

下面我按「小白 → 初级 → 中级 → 高级」的梯子写。你看到哪一段觉得够用了，就停。

> 说明：本文里所有没在我手头“官方摘录/变更说明”里核对到的字段细节，我都会标 **待核实**。避免我嘴快把你带沟里。

---

## ACP 解决的到底是什么问题？（小白）

**一句话：让 Agent “可接入、可路由、可治理”。**

以前你可能遇到过这些痛点：

- 你有好几个 Agent（写代码的、查资料的、写文的），但接法各不一样
- 同一个任务在不同渠道（Feishu/Telegram/Discord/命令行）触发，行为还不一致
- 线程里聊着聊着，Agent “跑丢上下文” 或 “串台”
- 想限制某些地方**只能用某几个 Agent**，没地方配

ACP（可以理解为一个**标准化的 Agent 接入与调用协议/运行方式**，具体定义待核实）要解决的就是：

**把 Agent 变成“像服务一样可配置”的组件**，并且在多渠道里可控地运行。

---

## ACP vs Subagents：它们啥关系？（初级）

先别把这俩当对立。

- **Subagents（子代理）**：更像 OpenClaw 内部的“分身/分工机制”。你把复杂任务拆出去，它帮你并行做。
- **ACP Agents**：更像“可插拔的外部/独立 Agent 运行单元”，通过 ACP 方式接入，能被统一路由、统一配置与治理。**待核实：ACP Agents 是否一定是外部进程/服务。**

你可以这样理解：

- **Subagents = 任务拆分的组织方式**
- **ACP Agents = 具体干活的工种（可配置、可接入）**

实际使用时很可能是组合拳：

主 Agent 接到需求 → 按任务拆 subagent → subagent 再去调用某个 ACP Agent（比如 coding / summarize / writer）。

---

## Quick Start（小白到初级）：怎么用起来？

你只需要记住三步：

1. **把 ACP 打开（或启用 ACP 相关配置）**（具体开关字段待核实）
2. **注册/声明可用的 ACP Agents**（例如：哪些 Agent 名字、入口、能力）
3. **把渠道（channels）和 ACP 的路由关系配好**：哪个渠道、哪个群/线程、允许叫谁干活

然后你在聊天里就能体验到：

- 同一个“指令/意图”，在不同渠道都能稳定触发
- 在一个 thread 里连续对话，Agent 能保持上下文（如果你启用了 thread 绑定）

> 如果你现在只想试水：先配一个 ACP Agent（比如“写作/总结”），再把它挂到一个测试频道。跑通闭环就行。

---

## 常见工作流（初级到中级）：你会真的用到的 4 种

### 1）一个入口，多种工种

- 你在 Feishu 私聊说：`帮我总结这个链接`
- 路由到 ACP 的 summarize agent
- 输出摘要 + 要点

**收益：**你不需要记“这个需求该找哪个机器人”，入口统一。

### 2）同渠道不同场景不同策略

- 群里：只允许轻量 agent（总结、问答）
- 私聊：允许重型 agent（代码、自动化、发消息）

**收益：**群里不炸；私聊才放开。

### 3）线程绑定：在同一条 thread 里持续做事

- 你在一个 thread 里持续补充信息
- Agent 只在这个 thread 的上下文里工作，不串到别的 thread

**收益：**减少串台，特别适合“PR review / 文档迭代 / 需求讨论”。

### 4）并发：把耗时任务拆出去

- 主对话里快速确认需求
- 子任务交给 subagent 并行跑
- 最终汇总回 thread

**收益：**你不用盯着等；信息结构也更清楚。

---

## 关键配置字段（中级）：acp.* 与 channels.* 你应该关心啥？

> 注意：这里我会用“概念字段名”描述；具体字段名/层级如果没摘录，我会标 **待核实**。你对照你自己的配置文件即可。

### acp.*（ACP 相关）

#### `acp.enabled`（待核实）

- 是否启用 ACP 支持
- 建议：先在测试环境打开

#### `acp.agents`（待核实）

- 声明/注册可用的 ACP Agents
- 你通常会配：
  - `name`：agent 名称（路由用）
  - `runtime`：运行方式（本地/容器/远程？待核实）
  - `endpoint/command`：入口（URL 或命令，待核实）
  - `allowedAgents`：白名单控制（见“高级调优”）

#### `acp.allowedAgents`（待核实）

- 用来限制“允许被调用的 agent 列表”
- 常见用途：
  - 在公共群禁用高风险 agent（比如能执行命令/改文件的）
  - 在某些频道只开放 writer/summarize

#### `acp.runtime.ttl`（待核实）

- 一个会话/运行实例的存活时间（Time To Live）
- 直觉上：ttl 越长，上下文越连续；ttl 越短，资源越省、串台风险越低

#### `acp.stream.chunk`（待核实）

- 流式输出的分片大小/节奏
- 你会在“输出太碎/刷屏”或“输出太慢/卡住”时调它

### channels.*（渠道相关：消息怎么进来、怎么分流）

#### `channels.<channel>.enabled`（待核实）

- 对某个渠道（Feishu/Telegram/Discord 等）是否启用

#### `channels.<channel>.routing`（待核实）

- 把消息路由到哪个 agent / 哪种策略
- 可能会按：
  - 私聊 / 群聊
  - thread / 非 thread
  - 频道 ID / 群 ID（白名单/黑名单）

#### `channels.<channel>.threadBound`（待核实）

- 是否把会话绑定到 thread（强烈建议在“讨论型工作流”里开）
- 配不好最常见的问题就是：**上下文串台** 或 **上下文丢失**

---

## 容易踩的坑（中级）：这些真会让你怀疑人生

1) **Agent 名称不统一**

- 配置里叫 `writer`，路由里写 `writing`
- 结果就是：看起来都启用了，但就是不工作

2) **threadBound 没开 / 开错范围**

- 不开：多个话题混在一个会话里，越聊越怪
- 乱开：你以为绑定了 thread，其实绑定到了整个群（待核实：具体行为取决于实现）

3) **allowedAgents 没配好**

- 太松：公共场景误触发高权限 agent（风险）
- 太紧：你以为能用，实际被拒绝（体验差）

4) **stream chunk 不合适**

- chunk 太小：刷屏、难读、消息被平台折叠
- chunk 太大：看起来像“卡住了”

5) **runtime ttl 不匹配你的工作流**

- ttl 太短：上下文频繁断，像金鱼记忆
- ttl 太长：资源占用上升，且更容易“带着旧上下文误判”

---

## 高级调优（高级）：想让它“更稳、更省、更可控”

### 1）Thread-bound sessions：把上下文锁在该锁的地方

适用场景：

- PR review 一个线程
- 文档打磨一个线程
- 需求评审一个线程

建议：

- **默认：公共场景开 threadBound（待核实）**
- 私聊可按需开（私聊本身就单线程，但也可能有多话题并行）

### 2）allowedAgents：治理 > 能力

你真正要的是：

- 在对的地方，放对的权限

一个实用策略（示例）：

- 公共群：`allowedAgents = [summarize, qa]`
- 项目群：`allowedAgents = [summarize, qa, review]`
- 私聊：`allowedAgents = [summarize, qa, writer, coding]`

> 字段名与挂载位置待核实，但“按场景收权限”的思想是通用的。

### 3）runtime ttl：为“连续性”付多少钱？

- 写作/讨论：ttl 可以长一点（连续上下文更重要）
- 轻量问答：ttl 短一点（省资源，减少误带上下文）

可选策略：

- 默认 ttl：中等
- 对 threadBound 会话：更长
- 对公共群：更短

（具体怎么分层配置取决于支持程度，待核实）

### 4）stream chunk：让“流式输出”更像人说话

你想要的是：

- **别刷屏**
- **别憋太久**
- **重点先出**

调参方向（经验向，细节待核实）：

- 平台容易折叠长消息：chunk 小一点、但别碎
- 平台对频发消息敏感：chunk 大一点、或降低发送频率

---

## 升级检查清单（极简版）

- [ ] 备份当前配置文件（别硬刚）
- [ ] 确认版本已包含 ACP Agents 支持（待核实：最低版本号）
- [ ] 在测试渠道启用 ACP（`acp.enabled` 待核实）
- [ ] 注册至少 1 个 ACP Agent（`acp.agents` 待核实）
- [ ] 配好 channels 路由：测试渠道 → 指向该 agent（字段待核实）
- [ ] 决定是否启用 threadBound（强烈建议在“讨论型 thread”里开，字段待核实）
- [ ] 配 allowedAgents 白名单：先收紧再放开（字段待核实）
- [ ] 跑一遍真实工作流：总结链接 / 写一段文案 / 多轮追问
- [ ] 观察输出体验：必要时调 `runtime ttl`、`stream chunk`（字段待核实）

---

## 结语

以前你是在“用机器人”。
现在更像是在“配团队”。

入口统一、权限可控、线程不串、行为可预期。
这就是 ACP Agents 带来的升级感。

> 你实装后把配置片段/报错/你想要的工作流发我，我会把所有 **待核实** 的字段名补全，并把你的踩坑整理成“能抄的配置 + 能复现的步骤”。

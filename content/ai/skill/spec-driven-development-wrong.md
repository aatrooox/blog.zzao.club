---
title: "规范驱动开发错在哪了"
author: "Jinx"
date: 2026-02-25
lastmod: 2026-02-25
tags:
  - Agent
  - 工程
  - 文档
description: "规范驱动开发的坑不在理念，而在规范作为文档会过时；如果规范能被人和 Agent 共同维护，它才不会说谎。"
---

原文链接：
- https://x.com/augmentcode/status/2025993446633492725
- https://x.com/dotey/status/2026146560862474482

侵删。

你唯一能百分百信任的文档，就是代码本身。

设计文档、更新日志、README、架构图、入职指南。这些东西写完几乎立刻就过时了。

让文档和不断变化的系统保持同步，需要持续投入成本。工程师天生习惯爆发式输出：写文档，发功能，然后做下一个。后续更新属于隐形工作，每天都要和其他任务争夺时间，而且几乎每次都会败下阵来。我们试过流程，试过工具，甚至试图把它塑造成团队价值观。都没用。因为我们总是在强求人类去做他们骨子里就不愿做的事。

这正是规范驱动开发经常翻车的地方。理念本身没毛病：与编写代码的 Agent 合作时，先写清楚需求再让它们放手干。这显然比在聊天窗口里随便贴几句提示词然后祈祷奇迹发生要靠谱得多。

但规范也是文档。文档的下场，我们刚才已经见识过了。

区别在于代价不同。过时的设计文档只会误导碰巧读到它的下一位工程师。而过时的规范会误导不知变通的 Agent。它们会自信满满地执行一个早已脱离实际的计划，根本不会发现哪里不对。

因此，在开发 Intent 的过程中，我们反复思考一个问题：如果规范不需要你来维护呢？如果它能自我更新呢？

这是我们最终的方案。

规范不再是人类或 Agent 的专属产物。双方都要去读写它。

你描述想做什么。协调 Agent 草拟规范，拆解任务。你审阅、修改，批准后才开始执行。一旦 Agent 开始干活，它们会将进展同步回规范中：发现了什么、改变了什么、遇到了哪些计划外的限制。你可以随时暂停，重写部分规范，Agent 就会接着新状态继续干。

回想一下，把任务交给优秀的初级工程师会怎样。你把工单给他们，他们去干活；发现 API 不支持工单里预设的分页方式时，他们会自己更新工单。他们不会等你发现问题，更不会将错就错。他们会跑来告诉你：“之前的假设不对，我改用这种方法了，原因是这样。”你审查他们的更新，批准或驳回。

这正是我们希望开发者和规范之间建立的关系。因为双方都在维护，工单才不至于“说谎”。

初级工程师这个比喻比你想的还要贴切。优秀的初级工程师不会把每行代码怎么写都向你汇报。他们只会反馈那些改变了方向的决策：“我发现了一个现成的 auth context，所以直接接入了，没去建新的。”这就是信号。这也正是你期望 Agent 做到的事。把握好这种颗粒度，成了系统设计中真正有趣的难题。细节太多，规范就会变成噪音，让你产生习惯性无视；细节太少，你又要重新去猜到底发生了什么。

实际任务是这样的。你写道：“在设置页面加个能跟随系统偏好的深色模式开关。”协调 Agent 读取代码库，草拟一份包含三个子任务的规范：添加开关组件、接入 preference store、更新 CSS 变量。

你扫了一眼，发现漏掉了跨会话保存选择这个细节，于是补上一句。

你点击批准。

Agent 开始干活。

15 分钟后，其中一个 Agent 更新了规范：“在代码库里找到了现成的 Theme Provider。已直接接入，未创建新 store。”

你审查代码变更（已按 Agent 和任务清晰分组）。

现在，这份规范反映了实际做出来的东西，而不是最初计划的东西。最重要的是，没人需要专门记着去更新它。

软件工程中所有“文档优先”的倡议之所以失败，原因如出一辙：它们都要求开发者去做那种没人看见、没人奖励的持续维护工作。

除非 Agent 也承担起自己那份维护工作，否则规范驱动开发也将重蹈覆辙。

既然 Agent 会写代码，它们也能更新计划。放手让它们干吧。
